#nullable enable

using UnrealSharp;
using UnrealSharp.Attributes;
using UnrealSharp.UnrealSharpCore;
using System;

namespace {{Namespace}};

public delegate void {{ClassName}}{{MethodName}}ActionDelegate({{#HasReturnType}}{{ReturnType}} Result, {{/HasReturnType}}string? Exception);

public class U{{ClassName}}{{MethodName}}ActionDelegate : MulticastDelegate<{{ClassName}}{{MethodName}}ActionDelegate>
{
    protected void Invoker({{#HasReturnType}}{{ReturnType}} Result, {{/HasReturnType}}string? Exception)
    {
        ProcessDelegate(IntPtr.Zero);
    }

    protected override {{ClassName}}{{MethodName}}ActionDelegate GetInvoker()
    {
        return Invoker;
    }
}

[UClass]
public class {{ClassName}}{{MethodName}}Action : UCSBlueprintAsyncActionBase
{
    private Task{{#HasReturnType}}<{{ReturnType}}>{{/HasReturnType}}? task;
    private Func<Task{{#HasReturnType}}<{{ReturnType}}>{{/HasReturnType}}>? asyncDelegate;

    [UProperty(PropertyFlags.BlueprintAssignable)]
    public TMulticastDelegate<{{ClassName}}{{MethodName}}ActionDelegate>? Completed { get; set; }

    [UProperty(PropertyFlags.BlueprintAssignable)]
    public TMulticastDelegate<{{ClassName}}{{MethodName}}ActionDelegate>? Failed { get; set; }

    {{#Attributes}}
    [{{Value}}]
    {{/Attributes}}
    [UMetaData("DefaultToSelf", "unit")]
    [UMetaData("BlueprintInternalUseOnly", "true")]
    public static {{ClassName}}{{MethodName}}Action {{MethodName}}({{ComponentClass}} unit{{#HasParameters}}, {{/HasParameters}}{{#Parameters}}{{Type}} {{Name}}{{#HasDefault}} = {{DefaultValue}}{{/HasDefault}}{{^IsLast}}, {{/IsLast}}{{/Parameters}})
    {
        var action = NewObject<{{ClassName}}{{MethodName}}Action>(unit);
        action.asyncDelegate = () => unit.{{MethodName}}({{#Parameters}}{{Name}}{{^IsLast}}, {{/IsLast}}{{/Parameters}}){{#ReturnsValueTask}}.AsTask(){{/ReturnsValueTask}};
        return action;
    }

    protected override void Activate()
    {
        if (asyncDelegate == null) { throw new InvalidOperationException("AsyncDelegate was null"); }
        task = asyncDelegate();
        task.ContinueWith(OnTaskCompleted);
    }

    private void OnTaskCompleted(Task{{#HasReturnType}}<{{ReturnType}}>{{/HasReturnType}} t)
    {
        if (UnrealSynchronizationContext.CurrentThread != NamedThread.GameThread)
        {
            new UnrealSynchronizationContext(NamedThread.GameThread, t).Post(_ => OnTaskCompleted(t), null);
            return;
        }
        if (IsDestroyed) { return; }
        if (t.IsFaulted)
        {
            Failed?.InnerDelegate.Invoke(default!, t.Exception?.ToString() ?? "Faulted without exception");
        }
        else
        {
            Completed?.InnerDelegate.Invoke(t.Result, null);
        }
    }
}
