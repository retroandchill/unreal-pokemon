#nullable enable
using static UnrealSharp.Interop.FTypeBuilderExporter;
using static UnrealSharp.Interop.FPropertyExporter;
using static UnrealSharp.Interop.UClassExporter;
using static UnrealSharp.Interop.UFunctionExporter;
using static System.ComponentModel.EditorBrowsableState;

using UnrealSharp;
using UnrealSharp.Core;
using UnrealSharp.Core.Marshallers;
using UnrealSharp.Core.Attributes;
using UnrealSharp.Interop;
using UnrealSharp.Attributes;
using UnrealSharp.CoreUObject;
using UnrealSharp.GameDataAccessTools;
using GameDataAccessTools.Core;
using GameDataAccessTools.Core.Views;
using GameDataAccessTools.Core.Utilities;
using ZLinq;
using System.ComponentModel;
using System.Runtime.CompilerServices;


namespace {{Namespace}};

[GeneratedType("{{EngineName}}", "{{Namespace}}")]
readonly partial record struct {{StructName}}(FName ID) : MarshalledStruct<{{StructName}}>, IDataHandle<{{EntryType}}>{{#Convertables}}, IEquatable<{{Type}}>{{/Convertables}}
{
    [EditorBrowsable(Never)]
    private static IntPtr NativeTypePtr = UCoreUObjectExporter.CallGetType("{{AssemblyName}}", "{{Namespace}}", "{{EngineName}}");

    [EditorBrowsable(Never)]
    private static int {{StructName}}_ID_Offset = FPropertyExporter.CallGetPropertyOffsetFromName(NativeTypePtr, "ID");

    private static int NativeDataSize = UScriptStructExporter.CallGetNativeStructSize(NativeTypePtr);
    public static int GetNativeDataSize() => NativeDataSize;
    public static IntPtr GetNativeClassPtr() => NativeTypePtr;
    public static {{StructName}} FromNative(IntPtr buffer) => new {{StructName}}(buffer);

    public void ToNative(IntPtr buffer) => BlittableMarshaller<{{StructName}}>.ToNative(buffer, 0, this);

    public {{StructName}}(IntPtr buffer) : this(BlittableMarshaller<FName>.FromNative(IntPtr.Add(buffer, {{StructName}}_ID_Offset), 0)) { }

    public static {{StructName}} None => new(FName.None);

    {{#WithRepository}}
    public static UScriptStruct EntryStruct => {{Provider}}.{{Repository}}.EntryStruct;

    static IEnumerable<FDataHandleEntry> IDataHandle.Entries => Entries.ToArray();

    public static ValueEnumerable<StructArrayValueEnumerator<{{EntryType}}, FDataHandleEntry>, FDataHandleEntry> Entries
    {
        get
        {
            return {{Provider}}.{{Repository}}.Entries
                .AsValueEnumerable(v => new FDataHandleEntry(v.ID{{#HasDisplayName}}, v.{{DisplayNameProperty}}{{/HasDisplayName}}));
        }
    }

    public bool IsValid => {{Provider}}.{{Repository}}.IsValidEntry(ID);

    public StructView<{{EntryType}}> Entry => {{Provider}}.{{Repository}}.GetEntry(ID);
    {{/WithRepository}}
    {{^WithRepository}}
    public static UScriptStruct EntryStruct => {{EntryType}}.StaticStruct;
    {{/WithRepository}}
    
    public static implicit operator {{StructName}}(in {{EntryType}} entry) 
    {
        return new {{StructName}}(entry.ID);
    } 

    public static implicit operator {{StructName}}(StructView<{{EntryType}}> entry)
    {
        return new {{StructName}}(entry.ID);
    }
    
    public static implicit operator {{StructName}}(FName name) 
    {
        return new {{StructName}}(name);
    }

    public static implicit operator {{StructName}}(string name)
    {
        return new {{StructName}}(name);
    }

    public static implicit operator FName({{StructName}} handle) => handle.ID;

    {{#Convertables}}
    public static implicit operator {{../StructName}}({{Type}} other)
    {
        return new {{StructName}}(other.ID);
    }

    {{/Convertables}}
    public bool Equals(FName other)
    {
        return ID.Equals(other);
    }

    {{#Convertables}}
    public bool Equals({{Type}} other)
    {
        return ID.Equals(other.ID);
    }

    {{/Convertables}}
    public static bool operator ==({{StructName}} left, FName right)
    {
        return left.Equals(right);
    }

    public static bool operator !=({{StructName}} left, FName right)
    {
        return !(left == right);
    }

    {{#Convertables}}
    public static bool operator ==({{../StructName}} left, {{Type}} right)
    {
        return left.Equals(right);
    }

    public static bool operator !=({{../StructName}} left, {{Type}} right)
    {
        return !(left == right);
    }

    {{/Convertables}}

    public override string ToString() => ID.ToString();
}
   

public static class {{StructName}}Marshaller
{
    public static void ToNative(IntPtr buffer, int index, {{StructName}} obj) => obj.ToNative(buffer + (index * {{StructName}}.GetNativeDataSize()));
    public static {{StructName}} FromNative(IntPtr buffer, int index) => new {{StructName}}(buffer + (index * {{StructName}}.GetNativeDataSize()));
}                                                                       

{{ModuleInitializer}}