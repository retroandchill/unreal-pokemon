#nullable enable
using UnrealSharp;
using UnrealSharp.Core;
using UnrealSharp.Core.Marshallers;
using UnrealSharp.Core.Attributes;
using UnrealSharp.Interop;
using UnrealSharp.Attributes;
using UnrealSharp.CoreUObject;
using UnrealSharp.GameDataAccessTools;
using GameDataAccessTools.Core;
using GameDataAccessTools.Core.Views;
using GameDataAccessTools.Core.Utilities;
using ZLinq;

namespace {{Namespace}};

readonly partial record struct {{StructName}} : MarshalledStruct<{{StructName}}>, IDataHandle<{{EntryType}}>{{#Convertables}}, IEquatable<{{Type}}>{{/Convertables}}
{
    public static {{StructName}} None => new(FName.None);

    {{#WithRepository}}
    /// <inheritdoc/>
    public static UScriptStruct EntryStruct => {{Provider}}.{{Repository}}.EntryStruct;

    static IEnumerable<FDataHandleEntry> IDataHandle.Entries => Entries.ToArray();

    public static ValueEnumerable<StructArrayValueEnumerator<{{EntryType}}, FDataHandleEntry>, FDataHandleEntry> Entries
    {
        get
        {
            return {{Provider}}.{{Repository}}.Entries
                .AsValueEnumerable(v => new FDataHandleEntry(v.ID{{#HasDisplayName}}, v.{{DisplayNameProperty}}{{/HasDisplayName}}));
        }
    }

    /// <inheritdoc/>
    public bool IsValid => {{Provider}}.{{Repository}}.IsValidEntry(ID);

    /// <inheritdoc/>
    public StructView<{{EntryType}}> Entry => {{Provider}}.{{Repository}}.GetEntry(ID);
    {{/WithRepository}}
    {{^WithRepository}}
    /// <inheritdoc/>
    public static UScriptStruct EntryStruct => {{EntryType}}.StaticStruct;
    {{/WithRepository}}
    
    public static implicit operator {{StructName}}(in {{EntryType}} entry) 
    {
        return new {{StructName}}(entry.ID);
    } 

    public static implicit operator {{StructName}}(StructView<{{EntryType}}> entry)
    {
        return new {{StructName}}(entry.ID);
    }
    
    public static implicit operator {{StructName}}(FName name) 
    {
        return new {{StructName}}(name);
    }

    public static implicit operator {{StructName}}(string name)
    {
        return new {{StructName}}(name);
    }

    public static implicit operator FName({{StructName}} handle) => handle.ID;

    {{#Convertables}}
    public static implicit operator {{../StructName}}({{Type}} other)
    {
        return new {{StructName}}(other.ID);
    }

    {{/Convertables}}
    /// <inheritdoc/>
    public bool Equals(FName other)
    {
        return ID.Equals(other);
    }

    {{#Convertables}}
    /// <inheritdoc/>
    public bool Equals({{Type}} other)
    {
        return ID.Equals(other.ID);
    }

    {{/Convertables}}
    public static bool operator ==({{StructName}} left, FName right)
    {
        return left.Equals(right);
    }

    public static bool operator !=({{StructName}} left, FName right)
    {
        return !(left == right);
    }

    {{#Convertables}}
    public static bool operator ==({{../StructName}} left, {{Type}} right)
    {
        return left.Equals(right);
    }

    public static bool operator !=({{../StructName}} left, {{Type}} right)
    {
        return !(left == right);
    }

    {{/Convertables}}

    /// <inheritdoc/>
    public override string ToString() => ID.ToString();
}